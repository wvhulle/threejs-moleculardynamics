<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<link rel="stylesheet" href="css/main.css">
		<link rel="shortcut icon" href="#" />
	</head>
	<body>
        <div id="info">Will display time elapsed once running</div>
		<script src="js/three.js"></script>

		
		<script>
            // Background scene Initialization
			var scene = new THREE.Scene();
			scene.background = new THREE.Color('white');
			
            // Camera
            var heightcamera = 5;
            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            camera.position.z = heightcamera;

            // Renderer
            var renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setClearColor("#e5e5e5");
            //renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            window.addEventListener('resize', () => {
                
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth,window.innerHeight);
            }, false);
            
            
            // Box
            var N = 10;
            var widthbox = heightcamera;
            var boxmaterial = new THREE.MeshBasicMaterial( { color: 0x00aa00 ,opacity:0.1, transparent: true, wireframe: true} );
            bounds = [];
            for (i = 0; i<1; i++) {
            
                var boxgeometry = new THREE.BoxGeometry(widthbox,widthbox,widthbox);
                
                var box = new THREE.Mesh( boxgeometry, boxmaterial );
                box.geometry.computeBoundingBox();
                boxgeometry.computeFaceNormals();
                
                
                
                var boundingbox = new THREE.Box3();
                
                bounds.push(box);
                
                scene.add( box );
            
            }

            
            // Balls
            var particlecolor = 0xFFCC00;
            var particleradius = (Math.sqrt((widthbox^3)*0.5))/10;
            var particlegeometry = new THREE.SphereGeometry(particleradius,8,8);
            var particlematerial = new THREE.MeshLambertMaterial( { color: particlecolor } );

            
            function getNRandomInt(min, max, N) {
                min = Math.ceil(min);
                max = Math.floor(max);
                rnmbs = [];
                var i = 0;
                for (i = 0; i<N; i++) {
                    rnmbs.push(Math.floor(Math.random() * (max - min + 1)) + min);
                    }
                return rnmbs;
            }
            
            
            function createParticles(n){
                var particles = []; var i;
                for (i = 0; i<n; i++) {
                    var mesh = new THREE.Mesh( particlegeometry, particlematerial );
                    rnmbslocation = getNRandomInt(-widthbox/2,widthbox/2,3);
                    mesh.position.set(...rnmbslocation);
                    var charge = 1, mass = 1;
                    rnmbsspeed = getNRandomInt(-widthbox/2,widthbox/2,3);
                    
                    var particlespeed = new THREE.Vector3(...rnmbsspeed);
                    var length = particlespeed.length();
                    var arrowHelper = new THREE.ArrowHelper(particlespeed, mesh.position, length, particlecolor);
                    //particles.push({mesh : particle, charge : charge , speed : speed, arrow : arrowHelper,  mass: mass});
                    particles.push({
                        mesh : mesh, 
                        charge : charge , 
                        speed : particlespeed, 
                        arrow : arrowHelper,
                        mass: mass
                    });
                    scene.add( mesh );
                    //scene.add( arrowHelper);

                }
                return particles;
            };
            
          
            
            var particles = createParticles(N);
            
            function addLight(...pos) {
                const color = 0xFFFFFF;
                const intensity = 1;
                const light = new THREE.DirectionalLight(color, intensity);
                light.position.set(-1, 2, 4);
                light.position.set(...pos);
                scene.add(light);
            }
            addLight(-1, 2, 4);
            addLight( 1, -1, -2);
            
            
            var clock = new THREE.Clock();
            var loop = 0;
            var render = function() {
                requestAnimationFrame(render); // no distortion upon resize or refresh
                dt = clock.getDelta();
                t = clock.getElapsedTime();
                document.getElementById('info').innerHTML = 'Time elapsed ' + t.toFixed(2);
                for (var i = 0, l = particles.length; i < l ; i++) {
                    // Bounce off walls x,y,z
                    if (Math.abs(particles[i].mesh.position.x) > widthbox/2-particleradius) {
                        
                        
                        var xnormal = new THREE.Vector3(1,0,0);
                        var xcorrectionspeed = -  particles[i].speed.clone().dot(xnormal);
                        var xcorrectionvector =  xnormal.multiplyScalar(xcorrectionspeed);
                        particles[i].speed.add(xcorrectionvector).add(xcorrectionvector);
                    }
                    
                    if (Math.abs(particles[i].mesh.position.y) > widthbox/2-particleradius) {
                        var ynormal = new THREE.Vector3(0,1,0);
                        var ycorrectionspeed = -  particles[i].speed.clone().dot(ynormal);
                        var ycorrectionvector =  ynormal.multiplyScalar(ycorrectionspeed);
                        
                        particles[i].speed.add(ycorrectionvector).add(ycorrectionvector);
                    }
                    
                    if (Math.abs(particles[i].mesh.position.z) > widthbox/2-particleradius) {
                        var znormal = new THREE.Vector3(0,0,1);
                        var zcorrectionspeed = -  particles[i].speed.clone().dot(znormal);
                        var zcorrectionvector =  znormal.multiplyScalar(zcorrectionspeed);
                        
                        particles[i].speed.add(zcorrectionvector).add(zcorrectionvector);
                    }
                    
                    
                    // Apply momentum change by interforces
                    for (var j = i ; j < N; j++) {
                    
                        var d = particles[i].mesh.position.distanceTo(particles[j].mesh.position);
                        
                        function lj(d) {
                            var epsilon = 0.01;
                            var sigma = particleradius*10;
                            return 4*epsilon*((sigma/d)^12- (sigma/d)^6);
                        }
                        
                        function coulomb(d) {
                            return ((0.0001)/d^2);
                        }
                    
                        var forcedirection =  particles[i].mesh.position.clone().sub(particles[j].mesh.position).normalize();
                        
                        particles[i].speed.add(forcedirection.multiplyScalar((particles[j].mass) * dt * lj(d)))

                    
                    }
                    
                    // Move forward
                    particles[i].mesh.position.add(particles[i].speed.clone().multiplyScalar(dt));
                
                    particles[i].arrow.position.set(particles[i].mesh.position);
                    particles[i].arrow.setDirection(particles[i].speed);
                }
                renderer.render(scene,camera);
                loop += 1;
                }
            render();
            

            

		</script>
	</body>
</html> 
