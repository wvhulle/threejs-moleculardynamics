<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Molecular dynamics simulator</title>
		<link rel="stylesheet" href="css/main.css">
		<link rel="shortcut icon" href="#" />
	</head>
	<body>
        <div id="info">Will display time elapsed once running</div>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r120/three.min.js "></script>
		<script type="text/javascript" src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/chance/1.1.7/chance.min.js" integrity="sha512-dELYIOEzIECWdvsEdoywFOB4qKDmtQee33yD0dQnzAE7eBGKJ984VQXRLs/vlsP4Sb3VchbQL7iAy4NWqetCsw==" crossorigin="anonymous"></script>
		
		
		<script>

            var widthbox =2;
            // Background scene Initialization
			var scene = new THREE.Scene();
			scene.background = new THREE.Color('white');
			
            // Camera
            var heightcamera = widthbox;
            
            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            camera.position.z = heightcamera;
            
            

            // Renderer
            var renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setClearColor("#e5e5e5");
            //renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            window.addEventListener('resize', () => {
                
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth,window.innerHeight);
            }, false);
            
            
            // Orbit
            var controls = new THREE.OrbitControls( camera, renderer.domElement  );
            controls.enableDamping = true;
            controls.autorotate = true;
            
            // Box
            var N = 10 ;
            var heightcamera = widthbox;
            var boxmaterial = new THREE.MeshBasicMaterial( { color: 0x00aa00 ,opacity:0.1, transparent: true, wireframe: true} );
            bounds = [];
            var boxgeometry = new THREE.BoxGeometry(widthbox,widthbox,widthbox);
            var box = new THREE.Mesh( boxgeometry, boxmaterial );
            //box.geometry.computeBoundingBox();
            //boxgeometry.computeFaceNormals();
            //var boundingbox = new THREE.Box3();
            
            bounds.push(box);
            
            scene.add( box );
            
            // Axis
            var axesHelper = new THREE.AxesHelper( 5 );
            scene.add( axesHelper );
    
            
            // Particles
            var particlecolor = 0xFFCC00;
            var minparticleradius = (Math.sqrt((widthbox^3)*0.5))/10;
            
            var particlematerial = new THREE.MeshLambertMaterial( { color: particlecolor } );

            
            function getNRandomInt(min, max, N) {
                min = Math.ceil(min);
                max = Math.floor(max);
                rnmbs = [];
                var i = 0;
                for (i = 0; i<N; i++) {
                    rnmbs.push(Math.floor(Math.random() * (max - min + 1)) + min);
                    }
                return rnmbs;
            }
            
            
            function createParticles(n){
                var my_chance = new Chance();
                var particles = []; var i;
                var charges = [-1,1]; var massdensity = 1;
                var averagevolume = 0.5 * widthbox * 3 / (N * 4 * Math.PI);
                var averageradius = Math.pow(averagevolume, 1/3)
                //console.log(averagevolume);
                for (i = 0; i<n; i++) {
                    
                    var particlecharge = charges[Math.floor(Math.random() * charges.length)]; 
                                
                    var particleradius = my_chance.floating({min: averageradius/2, max: averageradius});
                                       //console.log(particleradius);
                    var volume = (4*Math.PI/3)*(particleradius^3)
                    var particlemass = massdensity * volume
 
                    var particlegeometry = new THREE.SphereGeometry(particleradius,8,8);
                    var particlemesh = new THREE.Mesh( particlegeometry, particlematerial );
                    
                    // Location
                    rnmbslocation = getNRandomInt(-widthbox/2+particleradius,widthbox/2-particleradius,3);
                    particlemesh.position.set(...rnmbslocation);
                    
                    //Speed
                    rnmbsspeed = getNRandomInt(-widthbox/2,widthbox/2,3);
                    var particlespeed = new THREE.Vector3(...rnmbsspeed).multiplyScalar(1);
                    var length = particlespeed.length();
                    var arrowHelper = new THREE.ArrowHelper(particlespeed, particlemesh.position, length, particlecolor);
                    //particles.push({mesh : particle, charge : charge , speed : speed, arrow : arrowHelper,  mass: mass});
                    var startsinbox = true;
                    particles.push({
                        mesh : particlemesh, 
                        charge : particlecharge , 
                        speed : particlespeed, 
                        arrow : arrowHelper,
                        mass: particlemass,
                        radius: particleradius,
                        exit: startsinbox
                    });
                    scene.add( particlemesh );
                    //scene.add( arrowHelper);

                }
                return particles;
            };
            
          
            
            var particles = createParticles(N);
            
            function addLight(...pos) {
                const color = 0xFFFFFF;
                const intensity = 1;
                const light = new THREE.DirectionalLight(color, intensity);
                light.position.set(-1, 2, 4);
                light.position.set(...pos);
                scene.add(light);
            }
            addLight(-1, 2, 4);
            addLight( 1, -1, -2);
            
            
            var clock = new THREE.Clock();
            var loop = 0;
            var render = function() {
                requestId = requestAnimationFrame(render); // no distortion upon resize or refresh
                dt = clock.getDelta();
                t = clock.getElapsedTime();
                document.getElementById('info').innerHTML = 'Time elapsed ' + t.toFixed(2);
                for (var i = 0, l = particles.length; i < l ; i++) {
                
                    var particleradius = particles[i].radius;
                    var maxallowed = (widthbox/2-particleradius);
                    // Bounce off walls x,y,z
                    for (var k = 0; k < 3; k++) {
                        if (Math.abs(particles[i].mesh.position.getComponent(k)) > maxallowed) {

                            // Change speed, mirror
                            var normal=new THREE.Vector3(0,0,0);
                            normal.setComponent(k,1);
                            var correctionspeed = - particles[i].speed.clone().dot(normal);
                            var correctionvector =  normal.multiplyScalar(correctionspeed);
                            particles[i].speed.add(correctionvector).add(correctionvector);
                            
                            // Change position, move back in box
                            var d = Math.abs(Math.abs(particles[i].mesh.position.getComponent(k))-maxallowed);
                            if (particles[i].mesh.position.getComponent(k) > maxallowed) {
                                // Positive side
                                particles[i].mesh.position.setComponent(k,maxallowed-d)
                            } else {
                                // Negative side
                                particles[i].mesh.position.setComponent(k,-maxallowed +d)
                            }
                        }
                    }
                    
                    
                    // Apply momentum change by interforces
                    for (var j = i + 1 ; j < N; j++) {
                    
                        var d = particles[i].mesh.position.distanceTo(particles[j].mesh.position);
                        
                        // A scalar but wrong lennard-jones force
                        function lj(d,m1,m2) {
                            var epsilon = 0.01;
                            var sigma = particleradius*10;
                            return m1*m2*4*epsilon*(-12*(sigma/d)^11+6*(sigma/d)^5);
                        }
                        
                        function coulomb(d,q1,q2) {
                            var force = (q1*q2*(1)/(d^2));
                            if (force == NaN) {
                                force = 0;
                            }
                            return force;
                        }
                    
                        var forcedirection =  particles[j].mesh.position.clone().sub(particles[i].mesh.position).normalize();
                        
                        var m1 = particles[i].mass;
                        var q1 = particles[i].charge;
                        var m2 = particles[j].mass;
                        var q2 = particles[j].charge;
                        
                        var dv = (1/m1) * dt * coulomb(d,m1,m2);
                        if (dv > 0 && dv != Infinity) {
                            particles[i].speed.add(forcedirection.clone().multiplyScalar(dv))
                        }

                    }
                    
                    //console.log(particles[i].speed)
                    
                    // Checks on boundaries
                    var old_position = particles[i].mesh.position.clone()
                    var new_position =  particles[i].mesh.position.clone().add(particles[i].speed.clone().multiplyScalar(dt));
                    var dx = new_position.clone().sub(old_position).lengthSq();
                    var maxdx = (widthbox*Math.pow(3,1/2))^2;
                    // Actual move
                    if (dx < maxdx) {
                        particles[i].mesh.position.add(particles[i].speed.clone().multiplyScalar(dt));
                    } else if (dx == Infinity) {
                        //console.log(i);
                        console.log(particles[i].speed.clone())
                        window.cancelAnimationFrame(requestId);
                    } else {
                        console.log(dx)
                        window.cancelAnimationFrame(requestId);
                    }

                    //particles[i].arrow.position.set(particles[i].mesh.position);
                    //particles[i].arrow.setDirection(particles[i].speed);
                }
                controls.update();
                renderer.render(scene,camera);
                loop += 1;
                }
            render();
            

            

		</script>
	</body>
</html> 
