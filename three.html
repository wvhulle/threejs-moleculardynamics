<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Molecular dynamics simulator</title>
		<link rel="stylesheet" href="css/main.css">
		<link rel="shortcut icon" href="#" />
	</head>
	<body>
        <div id="info">Will display time elapsed once running</div>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r120/three.min.js "></script>
		<script type="text/javascript" src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
		
		
		<script>
		
		
            // Background scene Initialization
			var scene = new THREE.Scene();
			scene.background = new THREE.Color('white');
			
            // Camera
            var heightcamera = 5;
            
            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            camera.position.z = heightcamera;
            
            

            // Renderer
            var renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setClearColor("#e5e5e5");
            //renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            window.addEventListener('resize', () => {
                
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth,window.innerHeight);
            }, false);
            
            
            // Orbit
            var controls = new THREE.OrbitControls( camera, renderer.domElement  );
            controls.enableDamping = true;
            controls.autorotate = true;
            
            // Box
            var N = 100 ;
            var widthbox = heightcamera;
            var boxmaterial = new THREE.MeshBasicMaterial( { color: 0x00aa00 ,opacity:0.1, transparent: true, wireframe: true} );
            bounds = [];
            for (i = 0; i<1; i++) {
            
                var boxgeometry = new THREE.BoxGeometry(widthbox,widthbox,widthbox);
                
                var box = new THREE.Mesh( boxgeometry, boxmaterial );
                box.geometry.computeBoundingBox();
                boxgeometry.computeFaceNormals();
                
                
                
                var boundingbox = new THREE.Box3();
                
                bounds.push(box);
                
                scene.add( box );
            
            }
            // Axis
            var axesHelper = new THREE.AxesHelper( 5 );
            scene.add( axesHelper );
    
            
            // Particles
            var particlecolor = 0xFFCC00;
            var particleradius = (Math.sqrt((widthbox^3)*0.5))/10;
            
            var particlematerial = new THREE.MeshLambertMaterial( { color: particlecolor } );

            
            function getNRandomInt(min, max, N) {
                min = Math.ceil(min);
                max = Math.floor(max);
                rnmbs = [];
                var i = 0;
                for (i = 0; i<N; i++) {
                    rnmbs.push(Math.floor(Math.random() * (max - min + 1)) + min);
                    }
                return rnmbs;
            }
            
            
            function createParticles(n){
                var particles = []; var i;
                for (i = 0; i<n; i++) {
                    
                    var charges = [-1];
                    
                    
                    
                    var particlecharge = charges[Math.floor(Math.random() * charges.length)]; 
                    
                    var particlemass = getNRandomInt(3,10,1)[0];
                    
                    var particlegeometry = new THREE.SphereGeometry(Math.pow(particlemass,1/3)*particleradius,8,8);
                    var particlemesh = new THREE.Mesh( particlegeometry, particlematerial );
                    
                    
                    // Location
                    rnmbslocation = getNRandomInt(-widthbox/2+particleradius,widthbox/2-particleradius,3);
                    particlemesh.position.set(...rnmbslocation);
                    
                    //Speed
                    rnmbsspeed = getNRandomInt(-widthbox/2,widthbox/2,3);
                    var particlespeed = new THREE.Vector3(...rnmbsspeed).multiplyScalar(0.01);
                    var length = particlespeed.length();
                    var arrowHelper = new THREE.ArrowHelper(particlespeed, particlemesh.position, length, particlecolor);
                    //particles.push({mesh : particle, charge : charge , speed : speed, arrow : arrowHelper,  mass: mass});
                    particles.push({
                        mesh : particlemesh, 
                        charge : particlecharge , 
                        speed : particlespeed, 
                        arrow : arrowHelper,
                        mass: particlemass
                    });
                    scene.add( particlemesh );
                    //scene.add( arrowHelper);

                }
                return particles;
            };
            
          
            
            var particles = createParticles(N);
            
            function addLight(...pos) {
                const color = 0xFFFFFF;
                const intensity = 1;
                const light = new THREE.DirectionalLight(color, intensity);
                light.position.set(-1, 2, 4);
                light.position.set(...pos);
                scene.add(light);
            }
            addLight(-1, 2, 4);
            addLight( 1, -1, -2);
            
            
            var clock = new THREE.Clock();
            var loop = 0;
            var render = function() {
                requestAnimationFrame(render); // no distortion upon resize or refresh
                dt = clock.getDelta();
                t = clock.getElapsedTime();
                document.getElementById('info').innerHTML = 'Time elapsed ' + t.toFixed(2);
                for (var i = 0, l = particles.length; i < l ; i++) {
                
                    
                
                    // Bounce off walls x,y,z
                    if (Math.abs(particles[i].mesh.position.x) > widthbox/2-particleradius) {
                        
                        
                        var xnormal = new THREE.Vector3(1,0,0);
                        var xcorrectionspeed = -  particles[i].speed.clone().dot(xnormal);
                        var xcorrectionvector =  xnormal.multiplyScalar(xcorrectionspeed);
                        particles[i].speed.add(xcorrectionvector).add(xcorrectionvector);
                    }
                    
                    if (Math.abs(particles[i].mesh.position.y) > widthbox/2-particleradius) {
                        var ynormal = new THREE.Vector3(0,1,0);
                        var ycorrectionspeed = -  particles[i].speed.clone().dot(ynormal);
                        var ycorrectionvector =  ynormal.multiplyScalar(ycorrectionspeed);
                        
                        particles[i].speed.add(ycorrectionvector).add(ycorrectionvector);
                    }
                    
                    if (Math.abs(particles[i].mesh.position.z) > widthbox/2-particleradius) {
                        var znormal = new THREE.Vector3(0,0,1);
                        var zcorrectionspeed = -  particles[i].speed.clone().dot(znormal);
                        var zcorrectionvector =  znormal.multiplyScalar(zcorrectionspeed);
                        
                        particles[i].speed.add(zcorrectionvector).add(zcorrectionvector);
                    }
                    
                    
                    // Apply momentum change by interforces
                    for (var j = i + 1 ; j < N; j++) {
                    
                        var d = particles[i].mesh.position.distanceTo(particles[j].mesh.position);
                        
                        // A scalar but wrong lennard-jones force
                        function lj(d,m1,m2) {
                            var epsilon = 0.01;
                            var sigma = particleradius*10;
                            return m1*m2*4*epsilon*(-12*(sigma/d)^11+6*(sigma/d)^5);
                        }
                        
                        function coulomb(d,q1,q2) {
                            return (q1*q2*(0.000001)/d^2);
                        }
                    
                        var forcedirection =  particles[j].mesh.position.clone().sub(particles[i].mesh.position).normalize();
                        
                        var m1 = particles[i].mass;
                        var q1 = particles[i].charge;
                        var m2 = particles[j].mass;
                        var q2 = particles[j].charge;
                        
                        var scalardiffmomentum = (1/m1) * dt * coulomb(d,m1,m2);
                        
               
                        
                        //particles[i].speed.add(forcedirection.clone().multiplyScalar(scalardiffmomentum))
                        
                        var scalardiffmomentum = 0;

                    
                    }
                    
                    console.log(particles[i].mesh.speed)
                    
                    // Move forward
                    particles[i].mesh.position.add(particles[i].speed);
                    particles[i].arrow.position.set(particles[i].mesh.position);
                    particles[i].arrow.setDirection(particles[i].speed);
                }
                controls.update();
                renderer.render(scene,camera);
                loop += 1;
                }
            render();
            

            

		</script>
	</body>
</html> 
