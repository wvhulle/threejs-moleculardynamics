<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<link rel="stylesheet" href="css/main.css">
		<link rel="shortcut icon" href="#" />
	</head>
	<body>
        <div id="info">Will display time elapsed once running</div>
		<script src="js/three.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
		<script>
            // Background scene Initialization
			var scene = new THREE.Scene();
			scene.background = new THREE.Color('white');
			
            // Camera
            var heightcamera = 5;
            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            camera.position.z = heightcamera;

            // Renderer
            var renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setClearColor("#e5e5e5");
            //renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            window.addEventListener('resize', () => {
                
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth,window.innerHeight);
            }, false);
            
            
            // Box
            var N = 10;
            var widthbox = heightcamera;
            var boxgeometry = new THREE.BoxGeometry(widthbox,widthbox,widthbox);
            var boxmaterial = new THREE.MeshPhongMaterial( { color: 0x00aa00 ,opacity:0.1, transparent: true, wireframe : true} );
            var box = new THREE.Mesh( boxgeometry, boxmaterial );
            box.geometry.computeBoundingBox();
            boxgeometry.computeFaceNormals();
            var boundingbox = new THREE.Box3();
            
            
            scene.add( box );
            
            
            // Balls
            var particlecolor = 0xFFCC00;
            var particlegeometry = new THREE.SphereGeometry(widthbox/N,8,8);
            var particlematerial = new THREE.MeshLambertMaterial( { color: particlecolor } );

            
            function getNRandomInt(min, max, N) {
                min = Math.ceil(min);
                max = Math.floor(max);
                rnmbs = [];
                var i = 0;
                for (i = 0; i<N; i++) {
                    rnmbs.push(Math.floor(Math.random() * (max - min + 1)) + min);
                    }
                return rnmbs;
            }
            
            
            function createParticles(n){
                var particles = []; var i;
                for (i = 0; i<n; i++) {
                    var mesh = new THREE.Mesh( particlegeometry, particlematerial );
                    rnmbslocation = getNRandomInt(-widthbox/2,widthbox/2,3);
                    mesh.position.set(...rnmbslocation);
                    var charge = 1, mass = 1;
                    rnmbsspeed = getNRandomInt(-widthbox/2,widthbox/2,3);
                    
                    var particlespeed = new THREE.Vector3(...rnmbsspeed);
                    var length = particlespeed.length();
                    var arrowHelper = new THREE.ArrowHelper(particlespeed, mesh.position, length, particlecolor);
                    //particles.push({mesh : particle, charge : charge , speed : speed, arrow : arrowHelper,  mass: mass});
                    particles.push({
                        mesh : mesh, 
                        charge : charge , 
                        speed : particlespeed, 
                        arrow : arrowHelper,
                        mass: mass
                    });
                    scene.add( mesh );
                    scene.add( arrowHelper);

                }
                return particles;
            };
            
          
            
            var particles = createParticles(N);
            
            function addLight(...pos) {
                const color = 0xFFFFFF;
                const intensity = 1;
                const light = new THREE.DirectionalLight(color, intensity);
                light.position.set(-1, 2, 4);
                light.position.set(...pos);
                scene.add(light);
            }
            addLight(-1, 2, 4);
            addLight( 1, -1, -2);
            
            
            var clock = new THREE.Clock();
            var loop = 0;
            var render = function() {
                requestAnimationFrame(render); // no distortion upon resize or refresh
                dt = clock.getDelta();
                t = clock.getElapsedTime();
                document.getElementById('info').innerHTML = 'Time elapsed ' + t.toFixed(2);
                for (var i = 0, l = particles.length; i < l ; i++) {
                    var mesh = particles[i].mesh;
                    var old_pos = mesh.position.clone();
                    var speed = particles[i].speed.clone();
                    var delta = speed.multiplyScalar(dt);
                    particles[i].mesh.position.add(delta);
                                        scene.updateMatrixWorld();

                    var new_pos = particles[i].mesh.position.clone();
                    var ray = new THREE.Raycaster(old_pos, speed.clone().normalize());
                    scene.updateMatrixWorld();
                    var intersects = ray.intersectObjects(scene.children);
                    
                    if ( intersects.length > 0 && intersects[0].distance < widthbox/N) {
                        
                        var raycastNormal = intersects[0].face.normal;
                        var raycastGroundPosition = intersects[0].point;
                        var distanceInside = 0.5-intersects[0].distance;
                        
                        //bounce back through wall
                        //x = x - d vn/v * n
                        particles[i].mesh.position.add( raycastNormal.clone().multiplyScalar(-speed.clone().normalize().dot(raycastNormal)).multiplyScalar(distanceInside)) 
                        
                        //console.log( raycastNormal.clone().multiplyScalar(-speed.clone().normalize().dot(raycastNormal)).multiplyScalar(distanceInside))
                        
                        //v = v - vn * n
                        //switch speed vector
                        particles[i].speed.add(raycastNormal.clone().multiplyScalar(-speed.clone().dot(raycastNormal)));
                        
                        
                    }
                    particles[i].arrow.position.set(particles[i].mesh.position);
                    particles[i].arrow.setDirection(particles[i].speed);
                    // var ray = new THREE.ray(old_pos,speed);
                    //boundingbox.copy( box.geometry.boundingBox ).applyMatrix4( box.matrixWorld );
                    
                    //var crash = ray.intersectsBox( boundingbox );
                    //if (crash) {
                    //    console.log('crash');
                    //}
                }
                renderer.render(scene,camera);
                loop += 1;
                }
            render();
            

            

		</script>
	</body>
</html> 
